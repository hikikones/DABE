\chapter{The PI3-Cluster Testbed}


\section{Installing an Operating System} \label{install_os}

To use the Raspberry Pi, an \gls{os} first needs to be installed. \href{https://www.raspberrypi.org/downloads/raspbian/}{Raspbian Buster Lite} is the official \gls{os} for Raspberry Pi 3, and is used on the gateway and router. \href{https://www.freebsd.org/}{FreeBSD} is used on the hosts.

After downloading the \gls{os}, uncompress the file. The extracted file should be of type \lstinline{.img}, containing a preinstalled \gls{os} that now must be written to the SD card. To write the image file to the SD card, several tools exists that can be used, with some examples following:

\begin{itemize}
    \item Raspberry Pi Imager (official, cross-platform)
    \item balenaEtcher (cross-platform)
    \item \lstinline{dd} (Linux)
\end{itemize}

Once the image has been successfully written, simply put the SD card into the Raspberry Pi machine and boot it. On Raspbian Buster, the default user that comes preinstalled is called \lstinline{pi}, with the default password \lstinline{raspberry}. On FreeBSD, two users are installed by default; \lstinline{root} and \lstinline{freebsd}, with the password being the same as the username.









\section{Keyboard Layout} \label{keyboard_layout}


\subsubsection{Raspbian Buster}

To change keyboard layout with a graphical user guide, run \lstinline{dpkg-reconfigure keyboard-configuration}. The resulting changes is permanently added.

For most full-sized keyboards, the following options are what one may want; \lstinline{Generic 105-key PC (intl.) -> Norwegian -> Norwegian -> The default for the keyboard layout -> No compose key}.


\subsubsection{FreeBSD}

To change keyboard layout with a graphical user guide, run \lstinline{kbdmap}. To make the changes persist, add the resulting configuration to the \lstinline{/etc/rc.conf} file. For example, if Norwegian was selected, run \lstinline{echo 'keymap="no.kbd"' >> /etc/rc.conf}.









\section{Root Account} \label{root_account}


\subsubsection{Raspbian Buster}

Once logged in with user \lstinline{pi}, create a root user with \lstinline{sudo passwd root}. Enter a chosen password. A root user has now been created. To use it, log out with \lstinline{logout} or simply reboot, and then log in as \lstinline{root}.

To delete the \lstinline{pi} user, issue the command \lstinline{deluser --remove-home pi} while logged in as \lstinline{root}.


\subsubsection{FreeBSD}

FreeBSD already comes preinstalled with two user accounts; \lstinline{root} and \lstinline{freebsd}. To delete the \lstinline{freebsd} user, log in as \lstinline{root} and run \lstinline{rmuser freebsd}.









\section{Updating the System} \label{update_system}


\subsubsection{Raspbian Buster}

\textbf{Note:} \textit{If the current system is using a custom kernel, upgrading the system will also upgrade the kernel, thus overwriting the custom kernel. One can omit the \lstinline{upgrade} part if that is not desired.}

To update the system, run \lstinline{apt update && apt upgrade}. If an error about \lstinline{release file not valid yet} appears, the system's clock needs to be fixed. This can easily be done with the \lstinline{date} tool; \lstinline{date -s "15 Feb 2020 12:00"}.


\subsubsection{FreeBSD}

To update the system, run the following:

\begin{minted}{bash}
# Update FreeBSD system
freebsd-update fetch && freebsd-update install

# Update FreeBSD packages
pkg upgrade
\end{minted}









\section{Enable SSH} \label{enable_ssh}

\todo{add SSH term and maybe passwordless access}

\subsubsection{Raspbian Buster}

To enable SSH access, simply run \lstinline{systemctl enable ssh}. To allow SSH root login, the line \lstinline{PermitRootLogin yes} must be added to the file \lstinline{/etc/ssh/sshd_config}, which can conveniently be done with \lstinline{echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config}. Then start SSH service with \lstinline{systemctl start ssh} or just reboot.


\subsubsection{FreeBSD}

SSH on FreeBSD is installed and enabled by default as seen by \lstinline{sshd_enable="YES"} in the file \lstinline{/etc/rc.conf}. However, root login must be explicitly allowed; \lstinline{echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config}. Reboot to apply the changes.

\textit{Note}: SSH access on FreeBSD can sometimes experience a long delay when establishing a connection. If this is the case, DNS lookup can be disabled with \lstinline{echo 'UseDNS no' >> /etc/ssh/sshd_config}.









\section{Change Hostname} \label{change_hostname}


\subsubsection{Raspbian Buster}

There are two files that needs to be edited in order to change hostname. First, the \lstinline{/etc/hostname} file, which only contains the current hostname. Simply change whatever is in it to what you want, say \lstinline{new_hostname}. Second, the file \lstinline{/etc/hosts} needs one line changed. Edit the line containg \lstinline{127.0.1.1} so that it looks as follows:

\begin{minted}{bash}
127.0.1.1       new_hostname
\end{minted}

A reboot will apply the changes.


\subsubsection{FreeBSD}

Only one file need to be changed. Open up the \lstinline{/etc/rc.conf} file, and replace the \lstinline{hostname} entry with the desired hostname. Reboot to apply the changes.









\section{Time Synchronization} \label{time_sync}

First, set up a common timezone on all machines. On Raspbian Buster, run \lstinline{timedatectl set-timezone CET}. On FreeBSD, run \lstinline{tzsetup CET}.


\subsubsection{NTP Server on Raspbian Buster}

Install \lstinline{ntp} with \lstinline{apt install ntp}. Then check if any \gls{ntp} peers are connected with \lstinline{ntpq -p}. If not, consider replacing the default pools or servers in \lstinline{/etc/ntp.conf} with another, such as \lstinline{server ntp.uio.no} followed up by \lstinline{systemctl restart ntp}.

\todo{find out why ntp server needs to be restarted on gateway upon boot}


\subsubsection{NTP Client on Raspbian Buster}

To automatically query for time from the \gls{ntp} server, the Raspbian Buster \gls{os} already comes with a lightweight daemon called \lstinline{systemd-timesyncd} that allows for synchronizing the system clock across the network. However, \gls{teacup} prefers to use \lstinline{ntp} instead, and so \lstinline{ntp} will be used.

Install \lstinline{ntp} with \lstinline{apt install ntp}. To specify which server to get the time from, prepare to edit the \lstinline{/etc/ntp.conf} file. Comment out the default pools, and add the entry \lstinline{server 10.0.1.254 iburst} which refers to the gateway.

Next, disable the \lstinline{systemd-timesyncd} with \lstinline{timedatectl set-ntp false} as we are using \lstinline{ntp} directly to update the time. Finally, either restart the service with \lstinline{systemctl restart ntp} or reboot. Wait a bit, and verify time synchronization with either \lstinline{ntpq -p} or simply \lstinline{date}.


\subsubsection{NTP Client on FreeBSD}

FreeBSD comes preinstalled with \lstinline{ntp}. To enable it on boot, run the following:

\begin{minted}{bash}
# Enable NTP on FreeBSD
echo 'ntpd_enable=YES' >> /etc/rc.conf
echo 'ntpd_sync_on_start=YES' >> /etc/rc.conf
\end{minted}

To specify which server to get the time from, prepare to edit the \lstinline{/etc/ntp.conf} file. Comment out any default pool or server entries, and add the new entry \lstinline{server 10.0.1.254 iburst} to it, which refers to the gateway. Reboot and verify time synchronization with \lstinline{date}.



















\chapter{TEACUP}


\section{Configurations} \label{teacup_configs}

\subsection{Performance} \label{app:teacup-performance}

The \gls{teacup} configuration file for the completed experiments related to performance in Section \ref{sec:performance} follows.

\begin{code}
\file{configuration file for performance experiments}
\begin{minted}{python}
import sys
import datetime
from fabric.api import env

#
# Fabric config
#

# User and password
env.user = 'root'
env.password = 'root'

# Set shell used to execute commands
env.shell = '/bin/sh -c'

# SSH connection timeout
env.timeout = 5

# Number of concurrent processes
env.pool_size = 2


#
# Testbed config
#

# Path to scripts
TPCONF_script_path = '/home/danny/teacup/teacup-1.1'
# DO NOT remove the following line
sys.path.append(TPCONF_script_path)

# Set debugging level (0 = no debugging info output) 
TPCONF_debug_level = 0

# Host lists
TPCONF_router = ['pi3router', ]
TPCONF_hosts = [ 'pi3host2', 'pi3host7', ]

# Map external IPs to internal IPs
TPCONF_host_internal_ip = {
    'pi3router': ['172.16.10.1', '172.16.20.1'],
    'pi3host2':  ['172.16.10.2'],
    'pi3host7':  ['172.16.20.7'],
}

#
# Experiment settings
#

# Maximum allowed time difference between machines in seconds
# otherwise experiment will abort cause synchronisation problems
TPCONF_max_time_diff = 2

# Experiment name prefix used if not set on the command line
# The command line setting will overrule this config setting
now = datetime.datetime.today()
# old default test ID prefix (version < 1.0)
#TPCONF_test_id = now.strftime("%Y%m%d-%H%M%S") + '_experiment'
# new default test ID prefix
TPCONF_test_id = 'exp_' + now.strftime("%Y%m%d-%H%M%S")

# Directory to store log files on remote host
TPCONF_remote_dir = '/root/tmp/'

# Time offset measurement options
# Enable broadcast ping on external/control interfaces
TPCONF_bc_ping_enable = '1'
# Specify rate of pings in packets/second
TPCONF_bc_ping_rate = 1
# Specify multicast address to use (must be broadcast or multicast address)
# If this is not specified, by default the ping will be send to the subnet
# broadcast address.
#TPCONF_bc_ping_address = '224.0.1.199'

# List of router queues/pipes

# Each entry is a tuple. The first value is the queue number and the second value
# is a comma separated list of parameters (see routersetup.py:init_pipe()).
# Queue numbers must be unique.

# Note that variable parameters must be either constants or or variable names
# defined by the experimenter. Variables are evaluated during runtime. Variable
# names must start with a 'V_'. Parameter names can only contain numbes, letter
# (upper and lower case), underscores (_), and hypen/minus (-).

# All variables must be defined in TPCONF_variable_list (see below).

# Note parameters must be configured appropriately for the router OS, e.g. there
# is no CoDel on FreeBSD; otherwise the experiment will abort witn an error.

TPCONF_router_queues = [
    # Set same delay for every host
    ('1', " source='172.16.10.0/24', dest='172.16.20.0/24', delay=V_delay, "
        " loss=V_loss, rate=V_up_rate, queue_disc=V_aqm, queue_size=V_bsize, "
        "queue_disc_params=V_aqm_params "),
    ('2', " source='172.16.20.0/24', dest='172.16.10.0/24', delay=V_delay, "
        " loss=V_loss, rate=V_down_rate, queue_disc=V_aqm, queue_size=V_bsize, "
        "queue_disc_params=V_aqm_params "),
]

# List of traffic generators

traffic_iperf = [
    # Specifying external addresses traffic will be created using the _first_
    # internal addresses (according to TPCONF_host_internal_ip)
    ('0.0', '1', " start_iperf, client='pi3host2', server='pi3host7', port=5000, "
        " duration=V_duration "),
]

# THIS is the traffic generator setup we will use
TPCONF_traffic_gens = traffic_iperf

# Parameter ranges

# Duration in seconds
TPCONF_duration = 60

# Number of runs for each setting
TPCONF_runs = 10

# If '1' enable ecn for all hosts, if '0' disable ecn for all hosts
TPCONF_ECN = ['1']

# TCP congestion control algorithm used
# Possible algos are: default, host<N>, newreno, cubic, cdg, hd, htcp, compound, vegas
# Note that the algo support is OS specific, so must ensure the right OS is booted
# Windows: newreno (default), compound
# FreeBSD: newreno (default), cubic, hd, htcp, cdg, vegas
# Linux: newreno, cubic (default), htcp, vegas
# If you specify 'default' the default algorithm depending on the OS will be used
# If you specify 'host<N>' where <N> is an integer starting from 0 to then the
# algorithm will be the N-th algorithm specified for the host in TPCONF_host_TCP_algos 
# (in case <N> is larger then the number of algorithms specified, it is set to 0
TPCONF_TCP_algos = [ 'host0', 'host1', 'host2', ]

# Specify TCP congestion control algorithms used on each host
TPCONF_host_TCP_algos = {
    'pi3host2': [ 'abe', 'newreno', 'cubic' ],
    'pi3host7': [ 'newreno', 'newreno', 'newreno' ],
}

# Specify TCP parameters for each host and each TCP congestion control algorithm
# Each parameter is of the form <sysctl name> = <value> where <value> can be a constant
# or a V_ variable
TPCONF_host_TCP_algo_params = {}

# Specify arbitray commands that are executed on a host at the end of the host 
# intialisation (after general host setup, ecn and tcp setup). The commands are
# executed in the shell as written after any V_ variables have been replaced.
# LIMITATION: only one V_ variable per command
TPCONF_host_init_custom_cmds = {
    'pi3host2' : [ 'sysctl net.inet.tcp.cc.abe=1' ],
    'pi3host7' : [ 'sysctl net.inet.tcp.cc.abe=1' ],
}

# Delays in ms
TPCONF_delays = [25, 50, 100, 200]

# Loss rates in percent
TPCONF_loss_rates = [0]

# Bandwidth (downstream, upstream)
# Note: Linux syntax
TPCONF_bandwidths = [
    ('10mbit', '10mbit'),
]

# AQM
# Note this is router OS specific
# Linux: fifo (mapped to pfifo), pfifo, bfifo, fq_codel, codel, pie, red, ...
#        (see tc man page for full list)
# FreeBSD: fifo, red
TPCONF_aqms = ['fq_codel', ]

# AQM parameters
# example for PIE: 'ecn target 20ms tupdate 30ms'
# check manual for more: man tc-pie, tc-fq_codel...
TPCONF_aqms_params = ['ecn', ]

# Buffer size
# If router is Linux this is mostly in packets/slots, but it depends on AQM
# (e.g. for bfifo it's bytes)
# If router is FreeBSD this would be in slots by default, but we can specify byte sizes
# (e.g. we can specify 4Kbytes)
TPCONF_buffer_sizes = [64]

# List of all parameters that can be varied

# The key of each item is the identifier that can be used in TPCONF_vary_parameters
# (see below).
# The value of each item is a 4-tuple. First, a list of variable names.
# Second, a list of short names uses for the file names.
# For each parameter varied a string '_<short_name>_<value>' is appended to the log
# file names (appended to chosen prefix). Note, short names should only be letters
# from a-z or A-Z. Do not use underscores or hyphens!
# Third, the list of parameters values. If there is more than one variable this must
# be a list of tuples, each tuple having the same number of items as teh number of
# variables. Fourth, an optional dictionary with additional variables, where the keys
# are the variable names and the values are the variable values.

TPCONF_parameter_list = {
#   Vary name		V_ variable	            file name	    values      extra vars
    'ecns' 	        :  (['V_ecn'],	        ['ecn'], 	    TPCONF_ECN, {}),
    'delays' 	    :  (['V_delay'], 	    ['del'], 	    TPCONF_delays, {}),
    'loss'  	    :  (['V_loss'], 	    ['loss'],   	TPCONF_loss_rates, {}),
    'tcpalgos' 	    :  (['V_tcp_cc_algo'],  ['tcp'], 	    TPCONF_TCP_algos, {}),
    'aqms'	        :  (['V_aqm'], 	        ['aqm'], 	    TPCONF_aqms, {}),
    'aqms_params'   :  (['V_aqm_params'],   ['aqm_params'], TPCONF_aqms_params, {}),
    'bsizes'	    :  (['V_bsize'], 	    ['bs'], 	    TPCONF_buffer_sizes, {}),
    'runs'	        :  (['V_runs'],         ['run'], 	    range(TPCONF_runs), {}),
    'bandwidths'    :  (['V_down_rate', 'V_up_rate'], ['down', 'up'], TPCONF_bandwidths, {}),
}

# Default setting for variables (used for variables if not varied)

# The key of each item is the parameter  name. The value of each item is the default
# parameter value used if the variable is not varied.

TPCONF_variable_defaults = {
#   V_ variable			    value
    'V_ecn'  		    :	TPCONF_ECN[0],
    'V_duration'  	    :	TPCONF_duration,
    'V_delay'  		    :	TPCONF_delays[0],
    'V_loss'   		    :	TPCONF_loss_rates[0],
    'V_tcp_cc_algo' 	:	TPCONF_TCP_algos[0],
    'V_down_rate'   	:	TPCONF_bandwidths[0][0],
    'V_up_rate'	    	:	TPCONF_bandwidths[0][1],
    'V_aqm'	    	    :	TPCONF_aqms[0],
    'V_aqm_params'      :   TPCONF_aqms_params[0],
    'V_bsize'	    	:	TPCONF_buffer_sizes[0],
    'V_test'	    	:	'foobar',
}

# Specify the parameters we vary through all values, all others will be fixed
# according to TPCONF_variable_defaults
TPCONF_vary_parameters = ['tcpalgos', 'delays', 'loss', 'bandwidths',
                            'aqms', 'aqms_params', 'bsizes', 'runs', ]    
\end{minted}
\captionof{listing}{The configuration file for \gls{teacup} in order to conduct experiments related to the performance of \gls{dabe}.}
\label{code:teacup-performance}
\end{code}






\subsection{Mixed Flows} \label{app:teacup-mixed}

The \gls{teacup} configuration file for the completed experiments related to mixed flows in Section \ref{sec:mixed-flows} follows.

\begin{code}
\file{configuration file for mixed flows experiments}
\begin{minted}{python}
import sys
import datetime
from fabric.api import env

#
# Fabric config
#

# User and password
env.user = 'root'
env.password = 'root'

# Set shell used to execute commands
env.shell = '/bin/sh -c'

# SSH connection timeout
env.timeout = 5

# Number of concurrent processes
env.pool_size = 2


#
# Testbed config
#

# Path to scripts
TPCONF_script_path = '/home/danny/teacup/teacup-1.1'
# DO NOT remove the following line
sys.path.append(TPCONF_script_path)

# Set debugging level (0 = no debugging info output) 
TPCONF_debug_level = 0

# Host lists
TPCONF_router = ['pi3router', ]
TPCONF_hosts = [ 'pi3host2', 'pi3host3', 'pi3host4', 'pi3host7', ]

# Map external IPs to internal IPs
TPCONF_host_internal_ip = {
    'pi3router': ['172.16.10.1', '172.16.20.1'],
    'pi3host2':  ['172.16.10.2'],
    'pi3host3':  ['172.16.10.3'],
    'pi3host4':  ['172.16.10.4'],
    'pi3host7':  ['172.16.20.7'],
}

#
# Experiment settings
#

# Maximum allowed time difference between machines in seconds
# otherwise experiment will abort cause synchronisation problems
TPCONF_max_time_diff = 2

# Experiment name prefix used if not set on the command line
# The command line setting will overrule this config setting
now = datetime.datetime.today()
# old default test ID prefix (version < 1.0)
#TPCONF_test_id = now.strftime("%Y%m%d-%H%M%S") + '_experiment'
# new default test ID prefix
TPCONF_test_id = 'exp_' + now.strftime("%Y%m%d-%H%M%S")

# Directory to store log files on remote host
TPCONF_remote_dir = '/root/tmp/'

# Time offset measurement options
# Enable broadcast ping on external/control interfaces
TPCONF_bc_ping_enable = '1'
# Specify rate of pings in packets/second
TPCONF_bc_ping_rate = 1
# Specify multicast address to use (must be broadcast or multicast address)
# If this is not specified, by default the ping will be send to the subnet
# broadcast address.
#TPCONF_bc_ping_address = '224.0.1.199'

# List of router queues/pipes

# Each entry is a tuple. The first value is the queue number and the second value
# is a comma separated list of parameters (see routersetup.py:init_pipe()).
# Queue numbers must be unique.

# Note that variable parameters must be either constants or or variable names
# defined by the experimenter. Variables are evaluated during runtime. Variable
# names must start with a 'V_'. Parameter names can only contain numbes, letter
# (upper and lower case), underscores (_), and hypen/minus (-).

# All variables must be defined in TPCONF_variable_list (see below).

# Note parameters must be configured appropriately for the router OS, e.g. there
# is no CoDel on FreeBSD; otherwise the experiment will abort witn an error.

TPCONF_router_queues = [
    # Set same delay for every host
    ('1', " source='172.16.10.0/24', dest='172.16.20.0/24', delay=V_delay, "
        " loss=V_loss, rate=V_up_rate, queue_disc=V_aqm, queue_size=V_bsize, "
        "queue_disc_params=V_aqm_params "),
    ('2', " source='172.16.20.0/24', dest='172.16.10.0/24', delay=V_delay, "
        " loss=V_loss, rate=V_down_rate, queue_disc=V_aqm, queue_size=V_bsize, "
        "queue_disc_params=V_aqm_params "),
]

# List of traffic generators

traffic_iperf = [
    # Specifying external addresses traffic will be created using the _first_
    # internal addresses (according to TPCONF_host_internal_ip)
    ('0.0', '1', " start_iperf, client='pi3host2', server='pi3host7', port=5000, "
        " duration=V_duration "),
    ('0.0', '2', " start_iperf, client='pi3host3', server='pi3host7', port=5000, "
    " duration=V_duration "),
    ('0.0', '3', " start_iperf, client='pi3host4', server='pi3host7', port=5000, "
    " duration=V_duration "),
]

# THIS is the traffic generator setup we will use
TPCONF_traffic_gens = traffic_iperf

# Parameter ranges

# Duration in seconds
TPCONF_duration = 60

# Number of runs for each setting
TPCONF_runs = 10

# If '1' enable ecn for all hosts, if '0' disable ecn for all hosts
TPCONF_ECN = ['1']

# TCP congestion control algorithm used
# Possible algos are: default, host<N>, newreno, cubic, cdg, hd, htcp, compound, vegas
# Note that the algo support is OS specific, so must ensure the right OS is booted
# Windows: newreno (default), compound
# FreeBSD: newreno (default), cubic, hd, htcp, cdg, vegas
# Linux: newreno, cubic (default), htcp, vegas
# If you specify 'default' the default algorithm depending on the OS will be used
# If you specify 'host<N>' where <N> is an integer starting from 0 to then the
# algorithm will be the N-th algorithm specified for the host in TPCONF_host_TCP_algos 
# (in case <N> is larger then the number of algorithms specified, it is set to 0
TPCONF_TCP_algos = [ 'host0', ]

# Specify TCP congestion control algorithms used on each host
TPCONF_host_TCP_algos = {
    'pi3host2': [ 'dabe', ],
    'pi3host3': [ 'newreno', ],
    'pi3host4': [ 'cubic', ],
    'pi3host7': [ 'newreno', ],
}

# Specify TCP parameters for each host and each TCP congestion control algorithm
# Each parameter is of the form <sysctl name> = <value> where <value> can be a constant
# or a V_ variable
TPCONF_host_TCP_algo_params = {}

# Specify arbitray commands that are executed on a host at the end of the host 
# intialisation (after general host setup, ecn and tcp setup). The commands are
# executed in the shell as written after any V_ variables have been replaced.
# LIMITATION: only one V_ variable per command
TPCONF_host_init_custom_cmds = {
    'pi3host2' : [ 'sysctl net.inet.tcp.cc.abe=1' ],
    'pi3host3' : [ 'sysctl net.inet.tcp.cc.abe=1' ],
    'pi3host4' : [ 'sysctl net.inet.tcp.cc.abe=0' ],
    'pi3host7' : [ 'sysctl net.inet.tcp.cc.abe=0' ],
}

# Delays in ms
TPCONF_delays = [25, 50, 100, 200]

# Loss rates in percent
TPCONF_loss_rates = [0]

# Bandwidth (downstream, upstream)
# Note: Linux syntax
TPCONF_bandwidths = [
    ('10mbit', '10mbit'),
]

# AQM
# Note this is router OS specific
# Linux: fifo (mapped to pfifo), pfifo, bfifo, fq_codel, codel, pie, red, ...
#        (see tc man page for full list)
# FreeBSD: fifo, red
TPCONF_aqms = ['fq_codel', ]

# AQM parameters
# example for PIE: 'ecn target 20ms tupdate 30ms'
# check manual for more: man tc-pie, tc-fq_codel...
TPCONF_aqms_params = ['ecn', ]

# Buffer size
# If router is Linux this is mostly in packets/slots, but it depends on AQM
# (e.g. for bfifo it's bytes)
# If router is FreeBSD this would be in slots by default, but we can specify byte sizes
# (e.g. we can specify 4Kbytes)
TPCONF_buffer_sizes = [64]

# List of all parameters that can be varied

# The key of each item is the identifier that can be used in TPCONF_vary_parameters
# (see below).
# The value of each item is a 4-tuple. First, a list of variable names.
# Second, a list of short names uses for the file names.
# For each parameter varied a string '_<short_name>_<value>' is appended to the log
# file names (appended to chosen prefix). Note, short names should only be letters
# from a-z or A-Z. Do not use underscores or hyphens!
# Third, the list of parameters values. If there is more than one variable this must
# be a list of tuples, each tuple having the same number of items as teh number of
# variables. Fourth, an optional dictionary with additional variables, where the keys
# are the variable names and the values are the variable values.

TPCONF_parameter_list = {
#   Vary name		V_ variable	            file name	    values      extra vars
    'ecns' 	        :  (['V_ecn'],	        ['ecn'], 	    TPCONF_ECN, {}),
    'delays' 	    :  (['V_delay'], 	    ['del'], 	    TPCONF_delays, {}),
    'loss'  	    :  (['V_loss'], 	    ['loss'],   	TPCONF_loss_rates, {}),
    'tcpalgos' 	    :  (['V_tcp_cc_algo'],  ['tcp'], 	    TPCONF_TCP_algos, {}),
    'aqms'	        :  (['V_aqm'], 	        ['aqm'], 	    TPCONF_aqms, {}),
    'aqms_params'   :  (['V_aqm_params'],   ['aqm_params'], TPCONF_aqms_params, {}),
    'bsizes'	    :  (['V_bsize'], 	    ['bs'], 	    TPCONF_buffer_sizes, {}),
    'runs'	        :  (['V_runs'],         ['run'], 	    range(TPCONF_runs), {}),
    'bandwidths'    :  (['V_down_rate', 'V_up_rate'], ['down', 'up'], TPCONF_bandwidths, {}),
}

# Default setting for variables (used for variables if not varied)

# The key of each item is the parameter  name. The value of each item is the default
# parameter value used if the variable is not varied.

TPCONF_variable_defaults = {
#   V_ variable			    value
    'V_ecn'  		    :	TPCONF_ECN[0],
    'V_duration'  	    :	TPCONF_duration,
    'V_delay'  		    :	TPCONF_delays[0],
    'V_loss'   		    :	TPCONF_loss_rates[0],
    'V_tcp_cc_algo' 	:	TPCONF_TCP_algos[0],
    'V_down_rate'   	:	TPCONF_bandwidths[0][0],
    'V_up_rate'	    	:	TPCONF_bandwidths[0][1],
    'V_aqm'	    	    :	TPCONF_aqms[0],
    'V_aqm_params'      :   TPCONF_aqms_params[0],
    'V_bsize'	    	:	TPCONF_buffer_sizes[0],
    'V_test'	    	:	'foobar',
}

# Specify the parameters we vary through all values, all others will be fixed
# according to TPCONF_variable_defaults
TPCONF_vary_parameters = ['tcpalgos', 'delays', 'loss', 'bandwidths',
                            'aqms', 'aqms_params', 'bsizes', 'runs', ]    
\end{minted}
\captionof{listing}{The configuration file for \gls{teacup} in order to conduct experiments related to the mixed flows with \gls{dabe}.}
\label{code:teacup-mixed}
\end{code}










\section{Utility Bash Scripts}


\subsubsection{Initiating TEACUP from remote x86 machine}

Since the tool \lstinline{spp} did not work on Raspberry Pi due to the ARM architecture (see \gls{teacup} section in \ref{teacup_gateway}), the experiment data needs to copied over to an x86 machine in order to analyze the results. This process quickly gets tedious when conducting many experiments. The following script automates the process. One only needs to make sure that the experiment folder from which the script is run has the necessary \lstinline{fabfile.py} included, and that the \lstinline{config.py} file reflects the path to where \lstinline{teacup-1.1} is located.

\begin{code}
\file{init\_teacup.sh}
\begin{minted}{bash}
#!/bin/sh

##############################################################
## A simple bash script for initiating a TEACUP experiment
## on a remote x86 machine in the same network.
## Make sure that fabfile.py is present in both locations.
## NOTE: Must run inside experiment folder where config.py is
##############################################################

# Gateway address can be IP address or hostname
GATEWAY=192.168.10.100
USER=root

# Target is the location of the TEACUP experiment folder on the gateway
# Make sure that this location is reflected in config.py
TARGET=/home/danny/teacup/experiment
OUTPUT=result

############################################
## Start TEACUP experiment
############################################

# Delete old results
ssh $USER@$GATEWAY rm $TARGET/experiments_started.txt
ssh $USER@$GATEWAY rm $TARGET/experiments_completed.txt
ssh $USER@$GATEWAY rm -rf $TARGET/$OUTPUT

# Copy config.py to gateway
scp config.py $USER@$GATEWAY:$TARGET

# Start TEACUP experiment
ssh $USER@$GATEWAY fab -f $TARGET/fabfile.py run_experiment_multiple:test_id=$OUTPUT

# Move new results to experiment folder
ssh $USER@$GATEWAY mv ./experiments_started.txt $TARGET
ssh $USER@$GATEWAY mv ./experiments_completed.txt $TARGET
ssh $USER@$GATEWAY mv ./$OUTPUT $TARGET

############################################
## Analyse TEACUP results
############################################

# Cleanup local
rm experiments_completed.txt experiments_started.txt
rm teacup_dir_cache.txt teacup_flow_cache.txt
rm -rf $OUTPUT

# Get new TEACUP results
scp -r $USER@$GATEWAY:$TARGET/* ./

# Analyse results
fab analyse_all
\end{minted}
\captionof{listing}{A utility bash script for initiating \gls{teacup} from a remote host, copying the results over and then analyzing them.}
\label{code:teacup-init}
\end{code}

















\chapter{FreeBSD CC Modules} \label{app:freebsd_cc_modules}

\section{NewReno} \label{cc_newreno}

This section includes the source code for the NewReno congestion control module in FreeBSD 12.1. The header file \lstinline{cc_newreno.h} \ref{code:newreno.h} and its implementation file \lstinline{cc_newreno.c} \ref{code:newreno.c} follows.

\begin{code}
\file{cc\_newreno.h}
\begin{minted}{c}
/*-
* Copyright (c) 2017 Tom Jones <tj@enoti.me>
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
* SUCH DAMAGE.
*
* $FreeBSD: releng/12.1/sys/netinet/cc/cc_newreno.h 331214 2018-03-19 16:37:47Z lstewart $
*/

#ifndef _CC_NEWRENO_H
#define _CC_NEWRENO_H

#define CCALGONAME_NEWRENO "newreno"

struct cc_newreno_opts {
    int			name;
    uint32_t	val;
};

#define CC_NEWRENO_BETA		1
#define CC_NEWRENO_BETA_ECN	2

#endif /* _CC_NEWRENO_H */
\end{minted}
\captionof{listing}{The header file for NewReno in FreeBSD.}
\label{code:newreno.h}
\end{code}

\begin{code}
\file{cc\_newreno.c}
\begin{minted}{c}
/*-
* SPDX-License-Identifier: BSD-2-Clause-FreeBSD
*
* Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995
*	The Regents of the University of California.
* Copyright (c) 2007-2008,2010,2014
*	Swinburne University of Technology, Melbourne, Australia.
* Copyright (c) 2009-2010 Lawrence Stewart <lstewart@freebsd.org>
* Copyright (c) 2010 The FreeBSD Foundation
* All rights reserved.
*
* This software was developed at the Centre for Advanced Internet
* Architectures, Swinburne University of Technology, by Lawrence Stewart, James
* Healy and David Hayes, made possible in part by a grant from the Cisco
* University Research Program Fund at Community Foundation Silicon Valley.
*
* Portions of this software were developed at the Centre for Advanced
* Internet Architectures, Swinburne University of Technology, Melbourne,
* Australia by David Hayes under sponsorship from the FreeBSD Foundation.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
* SUCH DAMAGE.
*/

/*
* This software was first released in 2007 by James Healy and Lawrence Stewart
* whilst working on the NewTCP research project at Swinburne University of
* Technology's Centre for Advanced Internet Architectures, Melbourne,
* Australia, which was made possible in part by a grant from the Cisco
* University Research Program Fund at Community Foundation Silicon Valley.
* More details are available at:
*   http://caia.swin.edu.au/urp/newtcp/
*
* Dec 2014 garmitage@swin.edu.au
* Borrowed code fragments from cc_cdg.c to add modifiable beta
* via sysctls.
*
*/

#include <sys/cdefs.h>
__FBSDID("$FreeBSD: releng/12.1/sys/netinet/cc/cc_newreno.c"
                        " 347901 2019-05-17 08:21:27Z tuexen $");

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/module.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>
#include <sys/systm.h>

#include <net/vnet.h>

#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_var.h>
#include <netinet/cc/cc.h>
#include <netinet/cc/cc_module.h>
#include <netinet/cc/cc_newreno.h>

static MALLOC_DEFINE(M_NEWRENO, "newreno data",
    "newreno beta values");

static void	newreno_cb_destroy(struct cc_var *ccv);
static void	newreno_ack_received(struct cc_var *ccv, uint16_t type);
static void	newreno_after_idle(struct cc_var *ccv);
static void	newreno_cong_signal(struct cc_var *ccv, uint32_t type);
static void	newreno_post_recovery(struct cc_var *ccv);
static int newreno_ctl_output(struct cc_var *ccv, struct sockopt *sopt, void *buf);

VNET_DEFINE_STATIC(uint32_t, newreno_beta) = 50;
VNET_DEFINE_STATIC(uint32_t, newreno_beta_ecn) = 80;
#define V_newreno_beta VNET(newreno_beta)
#define V_newreno_beta_ecn VNET(newreno_beta_ecn)

struct cc_algo newreno_cc_algo = {
    .name = "newreno",
    .cb_destroy = newreno_cb_destroy,
    .ack_received = newreno_ack_received,
    .after_idle = newreno_after_idle,
    .cong_signal = newreno_cong_signal,
    .post_recovery = newreno_post_recovery,
    .ctl_output = newreno_ctl_output,
};

struct newreno {
    uint32_t beta;
    uint32_t beta_ecn;
};

static inline struct newreno *
newreno_malloc(struct cc_var *ccv)
{
    struct newreno *nreno;

    nreno = malloc(sizeof(struct newreno), M_NEWRENO, M_NOWAIT);
    if (nreno != NULL) {
        /* NB: nreno is not zeroed, so initialise all fields. */
        nreno->beta = V_newreno_beta;
        nreno->beta_ecn = V_newreno_beta_ecn;
        ccv->cc_data = nreno;
    }

    return (nreno);
}

static void
newreno_cb_destroy(struct cc_var *ccv)
{
    free(ccv->cc_data, M_NEWRENO);
}

static void
newreno_ack_received(struct cc_var *ccv, uint16_t type)
{
    if (type == CC_ACK && !IN_RECOVERY(CCV(ccv, t_flags)) &&
        (ccv->flags & CCF_CWND_LIMITED)) {
        u_int cw = CCV(ccv, snd_cwnd);
        u_int incr = CCV(ccv, t_maxseg);

        /*
        * Regular in-order ACK, open the congestion window.
        * Method depends on which congestion control state we're
        * in (slow start or cong avoid) and if ABC (RFC 3465) is
        * enabled.
        *
        * slow start: cwnd <= ssthresh
        * cong avoid: cwnd > ssthresh
        *
        * slow start and ABC (RFC 3465):
        *   Grow cwnd exponentially by the amount of data
        *   ACKed capping the max increment per ACK to
        *   (abc_l_var * maxseg) bytes.
        *
        * slow start without ABC (RFC 5681):
        *   Grow cwnd exponentially by maxseg per ACK.
        *
        * cong avoid and ABC (RFC 3465):
        *   Grow cwnd linearly by maxseg per RTT for each
        *   cwnd worth of ACKed data.
        *
        * cong avoid without ABC (RFC 5681):
        *   Grow cwnd linearly by approximately maxseg per RTT using
        *   maxseg^2 / cwnd per ACK as the increment.
        *   If cwnd > maxseg^2, fix the cwnd increment at 1 byte to
        *   avoid capping cwnd.
        */
        if (cw > CCV(ccv, snd_ssthresh)) {
            if (V_tcp_do_rfc3465) {
                if (ccv->flags & CCF_ABC_SENTAWND)
                    ccv->flags &= ~CCF_ABC_SENTAWND;
                else
                    incr = 0;
            } else
                incr = max((incr * incr / cw), 1);
        } else if (V_tcp_do_rfc3465) {
            /*
            * In slow-start with ABC enabled and no RTO in sight?
            * (Must not use abc_l_var > 1 if slow starting after
            * an RTO. On RTO, snd_nxt = snd_una, so the
            * snd_nxt == snd_max check is sufficient to
            * handle this).
            *
            * XXXLAS: Find a way to signal SS after RTO that
            * doesn't rely on tcpcb vars.
            */
            if (CCV(ccv, snd_nxt) == CCV(ccv, snd_max))
                incr = min(ccv->bytes_this_ack,
                    ccv->nsegs * V_tcp_abc_l_var *
                    CCV(ccv, t_maxseg));
            else
                incr = min(ccv->bytes_this_ack, CCV(ccv, t_maxseg));
        }
        /* ABC is on by default, so incr equals 0 frequently. */
        if (incr > 0)
            CCV(ccv, snd_cwnd) = min(cw + incr,
                TCP_MAXWIN << CCV(ccv, snd_scale));
    }
}

static void
newreno_after_idle(struct cc_var *ccv)
{
    int rw;

    /*
    * If we've been idle for more than one retransmit timeout the old
    * congestion window is no longer current and we have to reduce it to
    * the restart window before we can transmit again.
    *
    * The restart window is the initial window or the last CWND, whichever
    * is smaller.
    *
    * This is done to prevent us from flooding the path with a full CWND at
    * wirespeed, overloading router and switch buffers along the way.
    *
    * See RFC5681 Section 4.1. "Restarting Idle Connections".
    */
    if (V_tcp_do_rfc3390)
        rw = min(4 * CCV(ccv, t_maxseg),
            max(2 * CCV(ccv, t_maxseg), 4380));
    else
        rw = CCV(ccv, t_maxseg) * 2;

    CCV(ccv, snd_cwnd) = min(rw, CCV(ccv, snd_cwnd));
}

/*
* Perform any necessary tasks before we enter congestion recovery.
*/
static void
newreno_cong_signal(struct cc_var *ccv, uint32_t type)
{
    struct newreno *nreno;
    uint32_t beta, beta_ecn, cwin, factor;
    u_int mss;

    cwin = CCV(ccv, snd_cwnd);
    mss = CCV(ccv, t_maxseg);
    nreno = ccv->cc_data;
    beta = (nreno == NULL) ? V_newreno_beta : nreno->beta;
    beta_ecn = (nreno == NULL) ? V_newreno_beta_ecn : nreno->beta_ecn;
    if (V_cc_do_abe && type == CC_ECN)
        factor = beta_ecn;
    else
        factor = beta;

    /* Catch algos which mistakenly leak private signal types. */
    KASSERT((type & CC_SIGPRIVMASK) == 0,
        ("%s: congestion signal type 0x%08x is private\n", __func__, type));

    cwin = max(((uint64_t)cwin * (uint64_t)factor) / (100ULL * (uint64_t)mss),
        2) * mss;

    switch (type) {
    case CC_NDUPACK:
        if (!IN_FASTRECOVERY(CCV(ccv, t_flags))) {
            if (IN_CONGRECOVERY(CCV(ccv, t_flags) &&
                V_cc_do_abe && V_cc_abe_frlossreduce)) {
                CCV(ccv, snd_ssthresh) =
                    ((uint64_t)CCV(ccv, snd_ssthresh) *
                    (uint64_t)beta) /
                    (100ULL * (uint64_t)beta_ecn);
            }
            if (!IN_CONGRECOVERY(CCV(ccv, t_flags)))
                CCV(ccv, snd_ssthresh) = cwin;
            ENTER_RECOVERY(CCV(ccv, t_flags));
        }
        break;
    case CC_ECN:
        if (!IN_CONGRECOVERY(CCV(ccv, t_flags))) {
            CCV(ccv, snd_ssthresh) = cwin;
            CCV(ccv, snd_cwnd) = cwin;
            ENTER_CONGRECOVERY(CCV(ccv, t_flags));
        }
        break;
    }
}

/*
* Perform any necessary tasks before we exit congestion recovery.
*/
static void
newreno_post_recovery(struct cc_var *ccv)
{
    int pipe;

    if (IN_FASTRECOVERY(CCV(ccv, t_flags))) {
        /*
        * Fast recovery will conclude after returning from this
        * function. Window inflation should have left us with
        * approximately snd_ssthresh outstanding data. But in case we
        * would be inclined to send a burst, better to do it via the
        * slow start mechanism.
        *
        * XXXLAS: Find a way to do this without needing curack
        */
        if (V_tcp_do_rfc6675_pipe)
            pipe = tcp_compute_pipe(ccv->ccvc.tcp);
        else
            pipe = CCV(ccv, snd_max) - ccv->curack;

        if (pipe < CCV(ccv, snd_ssthresh))
            /*
            * Ensure that cwnd does not collapse to 1 MSS under
            * adverse conditons. Implements RFC6582
            */
            CCV(ccv, snd_cwnd) = max(pipe, CCV(ccv, t_maxseg)) +
                CCV(ccv, t_maxseg);
        else
            CCV(ccv, snd_cwnd) = CCV(ccv, snd_ssthresh);
    }
}

static int
newreno_ctl_output(struct cc_var *ccv, struct sockopt *sopt, void *buf)
{
    struct newreno *nreno;
    struct cc_newreno_opts *opt;

    if (sopt->sopt_valsize != sizeof(struct cc_newreno_opts))
        return (EMSGSIZE);

    nreno = ccv->cc_data;
    opt = buf;

    switch (sopt->sopt_dir) {
    case SOPT_SET:
        /* We cannot set without cc_data memory. */
        if (nreno == NULL) {
            nreno = newreno_malloc(ccv);
            if (nreno == NULL)
                return (ENOMEM);
        }
        switch (opt->name) {
        case CC_NEWRENO_BETA:
            nreno->beta = opt->val;
            break;
        case CC_NEWRENO_BETA_ECN:
            if (!V_cc_do_abe)
                return (EACCES);
            nreno->beta_ecn = opt->val;
            break;
        default:
            return (ENOPROTOOPT);
        }
        break;
    case SOPT_GET:
        switch (opt->name) {
        case CC_NEWRENO_BETA:
            opt->val = (nreno == NULL) ?
                V_newreno_beta : nreno->beta;
            break;
        case CC_NEWRENO_BETA_ECN:
            opt->val = (nreno == NULL) ?
                V_newreno_beta_ecn : nreno->beta_ecn;
            break;
        default:
            return (ENOPROTOOPT);
        }
        break;
    default:
        return (EINVAL);
    }

    return (0);
}

static int
newreno_beta_handler(SYSCTL_HANDLER_ARGS)
{
    int error;
    uint32_t new;

    new = *(uint32_t *)arg1;
    error = sysctl_handle_int(oidp, &new, 0, req);
    if (error == 0 && req->newptr != NULL ) {
        if (arg1 == &VNET_NAME(newreno_beta_ecn) && !V_cc_do_abe)
            error = EACCES;
        else if (new == 0 || new > 100)
            error = EINVAL;
        else
            *(uint32_t *)arg1 = new;
    }

    return (error);
}

SYSCTL_DECL(_net_inet_tcp_cc_newreno);
SYSCTL_NODE(_net_inet_tcp_cc, OID_AUTO, newreno, CTLFLAG_RW, NULL,
    "New Reno related settings");

SYSCTL_PROC(_net_inet_tcp_cc_newreno, OID_AUTO, beta,
    CTLFLAG_VNET | CTLTYPE_UINT | CTLFLAG_RW,
    &VNET_NAME(newreno_beta), 3, &newreno_beta_handler, "IU",
    "New Reno beta, specified as number between 1 and 100");

SYSCTL_PROC(_net_inet_tcp_cc_newreno, OID_AUTO, beta_ecn,
    CTLFLAG_VNET | CTLTYPE_UINT | CTLFLAG_RW,
    &VNET_NAME(newreno_beta_ecn), 3, &newreno_beta_handler, "IU",
    "New Reno beta ecn, specified as number between 1 and 100");

DECLARE_CC_MODULE(newreno, &newreno_cc_algo);
\end{minted}
\captionof{listing}{The implementation file for NewReno in FreeBSD.}
\label{code:newreno.c}
\end{code}









\section{Dynamic ABE}

This section contains the source code for the implementation of our work on \gls{dabe}, along with instructions for how to use it. The code is based on the original NewReno module above in Appendix \ref{cc_newreno}, with the necessary modifications added. Our solution consists of only the implementation file \lstinline{cc_dabe.c} from \ref{code:dabe.c}, and the \lstinline{Makefile} from \ref{code:dabe-makefile} has been used to compile our kernel module.

To compile the module, the kernel source is needed as explained in Section \ref{sec:cc_in_freebsd}. With this in place, and both the \lstinline{cc_dabe.c} and \lstinline{Makefile} in the same directory, the following commands are used.

\begin{minted}{bash}
# Compile DABE
make
# Load DABE kernel module after compiled
make load
# Unload DABE
make unload
\end{minted}
The implemention file and its \lstinline{Makefile} follows.

\begin{code}
\file{cc\_dabe.c}
\begin{minted}{c}
/*-
* SPDX-License-Identifier: BSD-2-Clause-FreeBSD
*
* Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995
*	The Regents of the University of California.
* Copyright (c) 2007-2008,2010,2014
*	Swinburne University of Technology, Melbourne, Australia.
* Copyright (c) 2009-2010 Lawrence Stewart <lstewart@freebsd.org>
* Copyright (c) 2010 The FreeBSD Foundation
* All rights reserved.
*
* This software was developed at the Centre for Advanced Internet
* Architectures, Swinburne University of Technology, by Lawrence Stewart, James
* Healy and David Hayes, made possible in part by a grant from the Cisco
* University Research Program Fund at Community Foundation Silicon Valley.
*
* Portions of this software were developed at the Centre for Advanced
* Internet Architectures, Swinburne University of Technology, Melbourne,
* Australia by David Hayes under sponsorship from the FreeBSD Foundation.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
* SUCH DAMAGE.
*/

/*
* This software was first released in 2007 by James Healy and Lawrence Stewart
* whilst working on the NewTCP research project at Swinburne University of
* Technology's Centre for Advanced Internet Architectures, Melbourne,
* Australia, which was made possible in part by a grant from the Cisco
* University Research Program Fund at Community Foundation Silicon Valley.
* More details are available at:
*   http://caia.swin.edu.au/urp/newtcp/
*
* Dec 2014 garmitage@swin.edu.au
* Borrowed code fragments from cc_cdg.c to add modifiable beta
* via sysctls.
*
*/

#include <sys/cdefs.h>

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/module.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>
#include <sys/systm.h>

#include <net/vnet.h>

#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_var.h>
#include <netinet/cc/cc.h>
#include <netinet/cc/cc_module.h>

#include <sys/khelp.h>
#include <netinet/khelp/h_ertt.h>

static MALLOC_DEFINE(M_NEWRENO, "newreno_dabe data",
    "newreno_dabe beta values");

static void	newreno_dabe_cb_destroy(struct cc_var *ccv);
static void	newreno_dabe_ack_received(struct cc_var *ccv, uint16_t type);
static void	newreno_dabe_after_idle(struct cc_var *ccv);
static void	newreno_dabe_cong_signal(struct cc_var *ccv, uint32_t type);
static void	newreno_dabe_post_recovery(struct cc_var *ccv);
static int newreno_dabe_ctl_output(struct cc_var *ccv, struct sockopt *sopt, void *buf);
static int newreno_dabe_init(void);

VNET_DEFINE_STATIC(uint32_t, newreno_dabe_beta) = 50;
VNET_DEFINE_STATIC(uint32_t, newreno_dabe_beta_ecn) = 80;
#define V_newreno_dabe_beta VNET(newreno_dabe_beta)
#define V_newreno_dabe_beta_ecn VNET(newreno_dabe_beta_ecn)

VNET_DEFINE(int, cc_abe_frlossreduce) = 0;
#define V_cc_abe_frlossreduce VNET(cc_abe_frlossreduce)
VNET_DEFINE(int, cc_do_abe) = 1;
#define V_cc_do_abe VNET(cc_do_abe)
VNET_DEFINE(int, tcp_abc_l_var) = 2;
#define V_tcp_abc_l_var VNET(tcp_abc_l_var)
VNET_DEFINE(int, tcp_do_rfc3465) = 1;
#define V_tcp_do_rfc3465 VNET(tcp_do_rfc3465)
VNET_DEFINE(int, tcp_do_rfc3390) = 1;
#define V_tcp_do_rfc3390 VNET(tcp_do_rfc3390)
VNET_DEFINE(int, tcp_do_rfc6675_pipe) = 0;
#define V_tcp_do_rfc6675_pipe VNET(tcp_do_rfc6675_pipe)

struct cc_newreno_dabe_opts {
    int			name;
    uint32_t	val;
};

#define CC_NEWRENO_BETA		1
#define CC_NEWRENO_BETA_ECN	2

struct cc_algo newreno_dabe_cc_algo = {
    .name = "dabe",
    .cb_destroy = newreno_dabe_cb_destroy,
    .ack_received = newreno_dabe_ack_received,
    .after_idle = newreno_dabe_after_idle,
    .cong_signal = newreno_dabe_cong_signal,
    .post_recovery = newreno_dabe_post_recovery,
    .ctl_output = newreno_dabe_ctl_output,
    .mod_init = newreno_dabe_init,
};

static int32_t ertt_id;

struct newreno_dabe {
    uint32_t beta;
    uint32_t beta_ecn;
};

static int
newreno_dabe_init(void)
{
    ertt_id = khelp_get_id("ertt");
    if (ertt_id <= 0) {
        printf("%s: h_ertt module not found\n", __func__);
        return (ENOENT);
    }
    return (0);
}

static inline struct newreno_dabe *
newreno_dabe_malloc(struct cc_var *ccv)
{
    struct newreno_dabe *nreno;

    nreno = malloc(sizeof(struct newreno_dabe), M_NEWRENO, M_NOWAIT);
    if (nreno != NULL) {
        /* NB: nreno is not zeroed, so initialise all fields. */
        nreno->beta = V_newreno_dabe_beta;
        nreno->beta_ecn = V_newreno_dabe_beta_ecn;
        ccv->cc_data = nreno;
    }

    return (nreno);
}

static void
newreno_dabe_cb_destroy(struct cc_var *ccv)
{
    free(ccv->cc_data, M_NEWRENO);
}

static void
newreno_dabe_ack_received(struct cc_var *ccv, uint16_t type)
{
    if (type == CC_ACK && !IN_RECOVERY(CCV(ccv, t_flags)) &&
        (ccv->flags & CCF_CWND_LIMITED)) {
        u_int cw = CCV(ccv, snd_cwnd);
        u_int incr = CCV(ccv, t_maxseg);

        /*
        * Regular in-order ACK, open the congestion window.
        * Method depends on which congestion control state we're
        * in (slow start or cong avoid) and if ABC (RFC 3465) is
        * enabled.
        *
        * slow start: cwnd <= ssthresh
        * cong avoid: cwnd > ssthresh
        *
        * slow start and ABC (RFC 3465):
        *   Grow cwnd exponentially by the amount of data
        *   ACKed capping the max increment per ACK to
        *   (abc_l_var * maxseg) bytes.
        *
        * slow start without ABC (RFC 5681):
        *   Grow cwnd exponentially by maxseg per ACK.
        *
        * cong avoid and ABC (RFC 3465):
        *   Grow cwnd linearly by maxseg per RTT for each
        *   cwnd worth of ACKed data.
        *
        * cong avoid without ABC (RFC 5681):
        *   Grow cwnd linearly by approximately maxseg per RTT using
        *   maxseg^2 / cwnd per ACK as the increment.
        *   If cwnd > maxseg^2, fix the cwnd increment at 1 byte to
        *   avoid capping cwnd.
        */
        if (cw > CCV(ccv, snd_ssthresh)) {
            if (V_tcp_do_rfc3465) {
                if (ccv->flags & CCF_ABC_SENTAWND)
                    ccv->flags &= ~CCF_ABC_SENTAWND;
                else
                    incr = 0;
            } else
                incr = max((incr * incr / cw), 1);
        } else if (V_tcp_do_rfc3465) {
            /*
            * In slow-start with ABC enabled and no RTO in sight?
            * (Must not use abc_l_var > 1 if slow starting after
            * an RTO. On RTO, snd_nxt = snd_una, so the
            * snd_nxt == snd_max check is sufficient to
            * handle this).
            *
            * XXXLAS: Find a way to signal SS after RTO that
            * doesn't rely on tcpcb vars.
            */
            if (CCV(ccv, snd_nxt) == CCV(ccv, snd_max))
                incr = min(ccv->bytes_this_ack,
                    ccv->nsegs * V_tcp_abc_l_var *
                    CCV(ccv, t_maxseg));
            else
                incr = min(ccv->bytes_this_ack, CCV(ccv, t_maxseg));
        }
        /* ABC is on by default, so incr equals 0 frequently. */
        if (incr > 0)
            CCV(ccv, snd_cwnd) = min(cw + incr,
                TCP_MAXWIN << CCV(ccv, snd_scale));
    }
}

static void
newreno_dabe_after_idle(struct cc_var *ccv)
{
    int rw;

    /*
    * If we've been idle for more than one retransmit timeout the old
    * congestion window is no longer current and we have to reduce it to
    * the restart window before we can transmit again.
    *
    * The restart window is the initial window or the last CWND, whichever
    * is smaller.
    *
    * This is done to prevent us from flooding the path with a full CWND at
    * wirespeed, overloading router and switch buffers along the way.
    *
    * See RFC5681 Section 4.1. "Restarting Idle Connections".
    */
    if (V_tcp_do_rfc3390)
        rw = min(4 * CCV(ccv, t_maxseg),
            max(2 * CCV(ccv, t_maxseg), 4380));
    else
        rw = CCV(ccv, t_maxseg) * 2;

    CCV(ccv, snd_cwnd) = min(rw, CCV(ccv, snd_cwnd));
}

/*
* Perform any necessary tasks before we enter congestion recovery.
*/
static void
newreno_dabe_cong_signal(struct cc_var *ccv, uint32_t type)
{
    struct newreno_dabe *nreno;
    uint32_t beta, beta_ecn, cwin, factor;
    u_int mss;

    struct ertt *e_t = khelp_get_osd(CCV(ccv, osd), ertt_id);

    cwin = CCV(ccv, snd_cwnd);
    mss = CCV(ccv, t_maxseg);
    nreno = ccv->cc_data;
    beta = (nreno == NULL) ? V_newreno_dabe_beta : nreno->beta;
    beta_ecn = (nreno == NULL) ? V_newreno_dabe_beta_ecn : nreno->beta_ecn;
    if (V_cc_do_abe && type == CC_ECN)
        factor = beta_ecn;
    else
        factor = beta;

    /* Catch algos which mistakenly leak private signal types. */
    KASSERT((type & CC_SIGPRIVMASK) == 0,
        ("%s: congestion signal type 0x%08x is private\n", __func__, type));

    cwin = max(((uint64_t)cwin * (uint64_t)factor) / (100ULL * (uint64_t)mss),
        2) * mss;

    switch (type) {
    case CC_NDUPACK:
        if (!IN_FASTRECOVERY(CCV(ccv, t_flags))) {
            if (IN_CONGRECOVERY(CCV(ccv, t_flags) &&
                V_cc_do_abe && V_cc_abe_frlossreduce)) {
                CCV(ccv, snd_ssthresh) =
                    ((uint64_t)CCV(ccv, snd_ssthresh) *
                    (uint64_t)beta) /
                    (100ULL * (uint64_t)beta_ecn);
            }
            if (!IN_CONGRECOVERY(CCV(ccv, t_flags)))
                CCV(ccv, snd_ssthresh) = cwin;
            ENTER_RECOVERY(CCV(ccv, t_flags));
        }
        break;
    case CC_ECN:
        if (!IN_CONGRECOVERY(CCV(ccv, t_flags))) {
            CCV(ccv, snd_ssthresh) = CCV(ccv, snd_cwnd) * e_t->minrtt / e_t->rtt;
            CCV(ccv, snd_cwnd) = CCV(ccv, snd_ssthresh);
            ENTER_CONGRECOVERY(CCV(ccv, t_flags));
        }
        break;
    }
}

/*
* Perform any necessary tasks before we exit congestion recovery.
*/
static void
newreno_dabe_post_recovery(struct cc_var *ccv)
{
    int pipe;

    if (IN_FASTRECOVERY(CCV(ccv, t_flags))) {
        /*
        * Fast recovery will conclude after returning from this
        * function. Window inflation should have left us with
        * approximately snd_ssthresh outstanding data. But in case we
        * would be inclined to send a burst, better to do it via the
        * slow start mechanism.
        *
        * XXXLAS: Find a way to do this without needing curack
        */
        if (V_tcp_do_rfc6675_pipe)
            pipe = tcp_compute_pipe(ccv->ccvc.tcp);
        else
            pipe = CCV(ccv, snd_max) - ccv->curack;

        if (pipe < CCV(ccv, snd_ssthresh))
            /*
            * Ensure that cwnd does not collapse to 1 MSS under
            * adverse conditons. Implements RFC6582
            */
            CCV(ccv, snd_cwnd) = max(pipe, CCV(ccv, t_maxseg)) +
                CCV(ccv, t_maxseg);
        else
            CCV(ccv, snd_cwnd) = CCV(ccv, snd_ssthresh);
    }
}

static int
newreno_dabe_ctl_output(struct cc_var *ccv, struct sockopt *sopt, void *buf)
{
    struct newreno_dabe *nreno;
    struct cc_newreno_dabe_opts *opt;

    if (sopt->sopt_valsize != sizeof(struct cc_newreno_dabe_opts))
        return (EMSGSIZE);

    nreno = ccv->cc_data;
    opt = buf;

    switch (sopt->sopt_dir) {
    case SOPT_SET:
        /* We cannot set without cc_data memory. */
        if (nreno == NULL) {
            nreno = newreno_dabe_malloc(ccv);
            if (nreno == NULL)
                return (ENOMEM);
        }
        switch (opt->name) {
        case CC_NEWRENO_BETA:
            nreno->beta = opt->val;
            break;
        case CC_NEWRENO_BETA_ECN:
            if (!V_cc_do_abe)
                return (EACCES);
            nreno->beta_ecn = opt->val;
            break;
        default:
            return (ENOPROTOOPT);
        }
        break;
    case SOPT_GET:
        switch (opt->name) {
        case CC_NEWRENO_BETA:
            opt->val = (nreno == NULL) ?
                V_newreno_dabe_beta : nreno->beta;
            break;
        case CC_NEWRENO_BETA_ECN:
            opt->val = (nreno == NULL) ?
                V_newreno_dabe_beta_ecn : nreno->beta_ecn;
            break;
        default:
            return (ENOPROTOOPT);
        }
        break;
    default:
        return (EINVAL);
    }

    return (0);
}

static int
newreno_dabe_beta_handler(SYSCTL_HANDLER_ARGS)
{
    int error;
    uint32_t new;

    new = *(uint32_t *)arg1;
    error = sysctl_handle_int(oidp, &new, 0, req);
    if (error == 0 && req->newptr != NULL ) {
        if (arg1 == &VNET_NAME(newreno_dabe_beta_ecn) && !V_cc_do_abe)
            error = EACCES;
        else if (new == 0 || new > 100)
            error = EINVAL;
        else
            *(uint32_t *)arg1 = new;
    }

    return (error);
}

SYSCTL_DECL(_net_inet_tcp_cc_abe);
SYSCTL_NODE(_net_inet_tcp_cc, OID_AUTO, newreno_dabe, CTLFLAG_RW, NULL,
    "New Reno related settings");

SYSCTL_PROC(_net_inet_tcp_cc_abe, OID_AUTO, beta,
    CTLFLAG_VNET | CTLTYPE_UINT | CTLFLAG_RW,
    &VNET_NAME(newreno_dabe_beta), 3, &newreno_dabe_beta_handler, "IU",
    "New Reno beta, specified as number between 1 and 100");

SYSCTL_PROC(_net_inet_tcp_cc_abe, OID_AUTO, beta_ecn,
    CTLFLAG_VNET | CTLTYPE_UINT | CTLFLAG_RW,
    &VNET_NAME(newreno_dabe_beta_ecn), 3, &newreno_dabe_beta_handler, "IU",
    "New Reno beta ecn, specified as number between 1 and 100");

DECLARE_CC_MODULE(newreno_dabe, &newreno_dabe_cc_algo);
MODULE_DEPEND(newreno_dabe, ertt, 1, 1, 1);
\end{minted}
\captionof{listing}{The implementation file for \gls{dabe}.}
\label{code:dabe.c}
\end{code}

\begin{code}
\file{Makefile}
\begin{minted}{bash}
KMOD = cc_dabe
SRCS = cc_dabe.c
.include <bsd.kmod.mk>
\end{minted}
\captionof{listing}{The \lstinline{Makefile} for \lstinline{cc_dabe.c}.}
\label{code:dabe-makefile}
\end{code}