\chapter{The PI3-Cluster Testbed}


\section{Installing an Operating System} \label{install_os}

To use the Raspberry Pi, an \gls{os} first needs to be installed. \href{https://www.raspberrypi.org/downloads/raspbian/}{Raspbian Buster Lite} is the official \gls{os} for Raspberry Pi 3, and is used on the gateway and router. \href{https://www.freebsd.org/}{FreeBSD} is used on the hosts.

After downloading the \gls{os}, uncompress the file. The extracted file should be of type \lstinline{.img}, containing a preinstalled \gls{os} that now must be written to the SD card. To write the image file to the SD card, several tools exists that can be used, with some examples following:

\begin{itemize}
    \item Raspberry Pi Imager (official, cross-platform)
    \item balenaEtcher (cross-platform)
    \item \lstinline{dd} (Linux)
\end{itemize}

Once the image has been successfully written, simply put the SD card into the Raspberry Pi machine and boot it. On Raspbian Buster, the default user that comes preinstalled is called \lstinline{pi}, with the default password \lstinline{raspberry}. On FreeBSD, two users are installed by default; \lstinline{root} and \lstinline{freebsd}, with the password being the same as the username.









\section{Keyboard Layout} \label{keyboard_layout}


\subsubsection{Raspbian Buster}

To change keyboard layout with a graphical user guide, run \lstinline{dpkg-reconfigure keyboard-configuration}. The resulting changes is permanently added.

For most full-sized keyboards, the following options are what one may want; \lstinline{Generic 105-key PC (intl.) -> Norwegian -> Norwegian -> The default for the keyboard layout -> No compose key}.


\subsubsection{FreeBSD}

To change keyboard layout with a graphical user guide, run \lstinline{kbdmap}. To make the changes persist, add the resulting configuration to the \lstinline{/etc/rc.conf} file. For example, if Norwegian was selected, run \lstinline{echo 'keymap="no.kbd"' >> /etc/rc.conf}.









\section{Root Account} \label{root_account}


\subsubsection{Raspbian Buster}

Once logged in with user \lstinline{pi}, create a root user with \lstinline{sudo passwd root}. Enter a chosen password. A root user has now been created. To use it, log out with \lstinline{logout} or simply reboot, and then log in as \lstinline{root}.

To delete the \lstinline{pi} user, issue the command \lstinline{deluser --remove-home pi} while logged in as \lstinline{root}.


\subsubsection{FreeBSD}

FreeBSD already comes preinstalled with two user accounts; \lstinline{root} and \lstinline{freebsd}. To delete the \lstinline{freebsd} user, log in as \lstinline{root} and run \lstinline{rmuser freebsd}.









\section{Updating the System} \label{update_system}


\subsubsection{Raspbian Buster}

\textbf{Note:} \textit{If the current system is using a custom kernel, upgrading the system will also upgrade the kernel, thus overwriting the custom kernel. One can omit the \lstinline{upgrade} part if that is not desired.}

To update the system, run \lstinline{apt update && apt upgrade}. If an error about \lstinline{release file not valid yet} appears, the system's clock needs to be fixed. This can easily be done with the \lstinline{date} tool; \lstinline{date -s "15 Feb 2020 12:00"}.


\subsubsection{FreeBSD}

To update the system, run the following:

\begin{minted}{bash}
# Update FreeBSD system
freebsd-update fetch && freebsd-update install

# Update FreeBSD packages
pkg upgrade
\end{minted}









\section{Enable SSH} \label{enable_ssh}

\todo{add SSH term and maybe passwordless access}

\subsubsection{Raspbian Buster}

To enable SSH access, simply run \lstinline{systemctl enable ssh}. To allow SSH root login, the line \lstinline{PermitRootLogin yes} must be added to the file \lstinline{/etc/ssh/sshd_config}, which can conveniently be done with \lstinline{echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config}. Then start SSH service with \lstinline{systemctl start ssh} or just reboot.


\subsubsection{FreeBSD}

SSH on FreeBSD is installed and enabled by default as seen by \lstinline{sshd_enable="YES"} in the file \lstinline{/etc/rc.conf}. However, root login must be explicitly allowed; \lstinline{echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config}. Reboot to apply the changes.

\textit{Note}: SSH access on FreeBSD can sometimes experience a long delay when establishing a connection. If this is the case, DNS lookup can be disabled with \lstinline{echo 'UseDNS no' >> /etc/ssh/sshd_config}.









\section{Change Hostname} \label{change_hostname}


\subsubsection{Raspbian Buster}

There are two files that needs to be edited in order to change hostname. First, the \lstinline{/etc/hostname} file, which only contains the current hostname. Simply change whatever is in it to what you want, say \lstinline{new_hostname}. Second, the file \lstinline{/etc/hosts} needs one line changed. Edit the line containg \lstinline{127.0.1.1} so that it looks as follows:

\begin{minted}{bash}
127.0.1.1       new_hostname
\end{minted}

A reboot will apply the changes.


\subsubsection{FreeBSD}

Only one file need to be changed. Open up the \lstinline{/etc/rc.conf} file, and replace the \lstinline{hostname} entry with the desired hostname. Reboot to apply the changes.









\section{Time Synchronization} \label{time_sync}

First, set up a common timezone on all machines. On Raspbian Buster, run \lstinline{timedatectl set-timezone CET}. On FreeBSD, run \lstinline{tzsetup CET}.


\subsubsection{NTP Server on Raspbian Buster}

Install \lstinline{ntp} with \lstinline{apt install ntp}. Then check if any \gls{ntp} peers are connected with \lstinline{ntpq -p}. If not, consider replacing the default pools or servers in \lstinline{/etc/ntp.conf} with another, such as \lstinline{server ntp.uio.no} followed up by \lstinline{systemctl restart ntp}.

\todo{find out why ntp server needs to be restarted on gateway upon boot}


\subsubsection{NTP Client on Raspbian Buster}

To automatically query for time from the \gls{ntp} server, the Raspbian Buster \gls{os} already comes with a lightweight daemon called \lstinline{systemd-timesyncd} that allows for synchronizing the system clock across the network. However, \gls{teacup} prefers to use \lstinline{ntp} instead, and so \lstinline{ntp} will be used.

Install \lstinline{ntp} with \lstinline{apt install ntp}. To specify which server to get the time from, prepare to edit the \lstinline{/etc/ntp.conf} file. Comment out the default pools, and add the entry \lstinline{server 10.0.1.254 iburst} which refers to the gateway.

Next, disable the \lstinline{systemd-timesyncd} with \lstinline{timedatectl set-ntp false} as we are using \lstinline{ntp} directly to update the time. Finally, either restart the service with \lstinline{systemctl restart ntp} or reboot. Wait a bit, and verify time synchronization with either \lstinline{ntpq -p} or simply \lstinline{date}.


\subsubsection{NTP Client on FreeBSD}

FreeBSD comes preinstalled with \lstinline{ntp}. To enable it on boot, run the following:

\begin{minted}{bash}
# Enable NTP on FreeBSD
echo 'ntpd_enable=YES' >> /etc/rc.conf
echo 'ntpd_sync_on_start=YES' >> /etc/rc.conf
\end{minted}

To specify which server to get the time from, prepare to edit the \lstinline{/etc/ntp.conf} file. Comment out any default pool or server entries, and add the new entry \lstinline{server 10.0.1.254 iburst} to it, which refers to the gateway. Reboot and verify time synchronization with \lstinline{date}.



















\chapter{TEACUP}


\section{Configurations} \label{teacup_configs}









\section{Utility Bash Scripts}


\subsubsection{Initiating TEACUP from remote x86 machine}

Since the tool \lstinline{spp} did not work on Raspberry Pi due to the ARM architecture (see \gls{teacup} section in \ref{teacup_gateway}), the experiment data needs to copied over to an x86 machine in order to analyze the results. This process quickly gets tedious when conducting many experiments. The following script automates the process. One only needs to make sure that the experiment folder from which the script is run has the necessary \lstinline{fabfile.py} included, and that the \lstinline{config.py} file reflects the path to where \lstinline{teacup-1.1} is located.

\begin{code}
\file{init\_teacup.sh}
\begin{minted}{bash}
#!/bin/sh

##############################################################
## A simple bash script for initiating a TEACUP experiment
## on a remote x86 machine in the same network.
## Make sure that fabfile.py is present in both locations.
## NOTE: Must run inside experiment folder where config.py is
##############################################################

# Gateway address can be IP address or hostname
GATEWAY=192.168.10.100
USER=root

# Target is the location of the TEACUP experiment folder on the gateway
# Make sure that this location is reflected in config.py
TARGET=/home/danny/teacup/experiment
OUTPUT=result

############################################
## Start TEACUP experiment
############################################

# Delete old results
ssh $USER@$GATEWAY rm $TARGET/experiments_started.txt
ssh $USER@$GATEWAY rm $TARGET/experiments_completed.txt
ssh $USER@$GATEWAY rm -rf $TARGET/$OUTPUT

# Copy config.py to gateway
scp config.py $USER@$GATEWAY:$TARGET

# Start TEACUP experiment
ssh $USER@$GATEWAY fab -f $TARGET/fabfile.py run_experiment_single:test_id=$OUTPUT

# Move new results to experiment folder
ssh $USER@$GATEWAY mv ./experiments_started.txt $TARGET
ssh $USER@$GATEWAY mv ./experiments_completed.txt $TARGET
ssh $USER@$GATEWAY mv ./$OUTPUT $TARGET

############################################
## Analyze TEACUP results
############################################

# Cleanup local
rm experiments_completed.txt experiments_started.txt
rm teacup_dir_cache.txt teacup_flow_cache.txt
rm -rf $OUTPUT

# Get new TEACUP results
scp -r $USER@$GATEWAY:$TARGET/* ./

# Analyze results
fab analyse_all:test_id=$OUTPUT
#fab analyse_all:test_id=result,lnames='Receiver;Sender',plot_params="TC_TITLE\='Title'"
\end{minted}
\captionof{listing}{A utility bash script for initiating \gls{teacup} from a remote host, copying the results over and then analyzing them.}
\label{code:teacup-init}
\end{code}



















\chapter{FreeBSD CC Modules} \label{app:freebsd_cc_modules}

\section{NewReno} \label{cc_newreno}

\todo{brief description}

blabla header \lstinline{cc_newreno.h} \ref{code:newreno.h} and its implementation in \lstinline{cc_newreno.c} \ref{code:newreno.c}...



\begin{code}
\file{cc\_newreno.h}
\begin{minted}{c}
/*-
* Copyright (c) 2017 Tom Jones <tj@enoti.me>
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
* SUCH DAMAGE.
*
* $FreeBSD: releng/12.1/sys/netinet/cc/cc_newreno.h 331214 2018-03-19 16:37:47Z lstewart $
*/

#ifndef _CC_NEWRENO_H
#define _CC_NEWRENO_H

#define CCALGONAME_NEWRENO "newreno"

struct cc_newreno_opts {
    int			name;
    uint32_t	val;
};

#define CC_NEWRENO_BETA		1
#define CC_NEWRENO_BETA_ECN	2

#endif /* _CC_NEWRENO_H */
\end{minted}
\captionof{listing}{The header file for NewReno in FreeBSD.}
\label{code:newreno.h}
\end{code}

\begin{code}
\file{cc\_newreno.c}
\begin{minted}{c}
/*-
* SPDX-License-Identifier: BSD-2-Clause-FreeBSD
*
* Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995
*	The Regents of the University of California.
* Copyright (c) 2007-2008,2010,2014
*	Swinburne University of Technology, Melbourne, Australia.
* Copyright (c) 2009-2010 Lawrence Stewart <lstewart@freebsd.org>
* Copyright (c) 2010 The FreeBSD Foundation
* All rights reserved.
*
* This software was developed at the Centre for Advanced Internet
* Architectures, Swinburne University of Technology, by Lawrence Stewart, James
* Healy and David Hayes, made possible in part by a grant from the Cisco
* University Research Program Fund at Community Foundation Silicon Valley.
*
* Portions of this software were developed at the Centre for Advanced
* Internet Architectures, Swinburne University of Technology, Melbourne,
* Australia by David Hayes under sponsorship from the FreeBSD Foundation.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
* SUCH DAMAGE.
*/

/*
* This software was first released in 2007 by James Healy and Lawrence Stewart
* whilst working on the NewTCP research project at Swinburne University of
* Technology's Centre for Advanced Internet Architectures, Melbourne,
* Australia, which was made possible in part by a grant from the Cisco
* University Research Program Fund at Community Foundation Silicon Valley.
* More details are available at:
*   http://caia.swin.edu.au/urp/newtcp/
*
* Dec 2014 garmitage@swin.edu.au
* Borrowed code fragments from cc_cdg.c to add modifiable beta
* via sysctls.
*
*/

#include <sys/cdefs.h>
__FBSDID("$FreeBSD: releng/12.1/sys/netinet/cc/cc_newreno.c 347901 2019-05-17 08:21:27Z tuexen $");

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/module.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>
#include <sys/systm.h>

#include <net/vnet.h>

#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_var.h>
#include <netinet/cc/cc.h>
#include <netinet/cc/cc_module.h>
#include <netinet/cc/cc_newreno.h>

static MALLOC_DEFINE(M_NEWRENO, "newreno data",
    "newreno beta values");

static void	newreno_cb_destroy(struct cc_var *ccv);
static void	newreno_ack_received(struct cc_var *ccv, uint16_t type);
static void	newreno_after_idle(struct cc_var *ccv);
static void	newreno_cong_signal(struct cc_var *ccv, uint32_t type);
static void	newreno_post_recovery(struct cc_var *ccv);
static int newreno_ctl_output(struct cc_var *ccv, struct sockopt *sopt, void *buf);

VNET_DEFINE_STATIC(uint32_t, newreno_beta) = 50;
VNET_DEFINE_STATIC(uint32_t, newreno_beta_ecn) = 80;
#define V_newreno_beta VNET(newreno_beta)
#define V_newreno_beta_ecn VNET(newreno_beta_ecn)

struct cc_algo newreno_cc_algo = {
    .name = "newreno",
    .cb_destroy = newreno_cb_destroy,
    .ack_received = newreno_ack_received,
    .after_idle = newreno_after_idle,
    .cong_signal = newreno_cong_signal,
    .post_recovery = newreno_post_recovery,
    .ctl_output = newreno_ctl_output,
};

struct newreno {
    uint32_t beta;
    uint32_t beta_ecn;
};

static inline struct newreno *
newreno_malloc(struct cc_var *ccv)
{
    struct newreno *nreno;

    nreno = malloc(sizeof(struct newreno), M_NEWRENO, M_NOWAIT);
    if (nreno != NULL) {
        /* NB: nreno is not zeroed, so initialise all fields. */
        nreno->beta = V_newreno_beta;
        nreno->beta_ecn = V_newreno_beta_ecn;
        ccv->cc_data = nreno;
    }

    return (nreno);
}

static void
newreno_cb_destroy(struct cc_var *ccv)
{
    free(ccv->cc_data, M_NEWRENO);
}

static void
newreno_ack_received(struct cc_var *ccv, uint16_t type)
{
    if (type == CC_ACK && !IN_RECOVERY(CCV(ccv, t_flags)) &&
        (ccv->flags & CCF_CWND_LIMITED)) {
        u_int cw = CCV(ccv, snd_cwnd);
        u_int incr = CCV(ccv, t_maxseg);

        /*
        * Regular in-order ACK, open the congestion window.
        * Method depends on which congestion control state we're
        * in (slow start or cong avoid) and if ABC (RFC 3465) is
        * enabled.
        *
        * slow start: cwnd <= ssthresh
        * cong avoid: cwnd > ssthresh
        *
        * slow start and ABC (RFC 3465):
        *   Grow cwnd exponentially by the amount of data
        *   ACKed capping the max increment per ACK to
        *   (abc_l_var * maxseg) bytes.
        *
        * slow start without ABC (RFC 5681):
        *   Grow cwnd exponentially by maxseg per ACK.
        *
        * cong avoid and ABC (RFC 3465):
        *   Grow cwnd linearly by maxseg per RTT for each
        *   cwnd worth of ACKed data.
        *
        * cong avoid without ABC (RFC 5681):
        *   Grow cwnd linearly by approximately maxseg per RTT using
        *   maxseg^2 / cwnd per ACK as the increment.
        *   If cwnd > maxseg^2, fix the cwnd increment at 1 byte to
        *   avoid capping cwnd.
        */
        if (cw > CCV(ccv, snd_ssthresh)) {
            if (V_tcp_do_rfc3465) {
                if (ccv->flags & CCF_ABC_SENTAWND)
                    ccv->flags &= ~CCF_ABC_SENTAWND;
                else
                    incr = 0;
            } else
                incr = max((incr * incr / cw), 1);
        } else if (V_tcp_do_rfc3465) {
            /*
            * In slow-start with ABC enabled and no RTO in sight?
            * (Must not use abc_l_var > 1 if slow starting after
            * an RTO. On RTO, snd_nxt = snd_una, so the
            * snd_nxt == snd_max check is sufficient to
            * handle this).
            *
            * XXXLAS: Find a way to signal SS after RTO that
            * doesn't rely on tcpcb vars.
            */
            if (CCV(ccv, snd_nxt) == CCV(ccv, snd_max))
                incr = min(ccv->bytes_this_ack,
                    ccv->nsegs * V_tcp_abc_l_var *
                    CCV(ccv, t_maxseg));
            else
                incr = min(ccv->bytes_this_ack, CCV(ccv, t_maxseg));
        }
        /* ABC is on by default, so incr equals 0 frequently. */
        if (incr > 0)
            CCV(ccv, snd_cwnd) = min(cw + incr,
                TCP_MAXWIN << CCV(ccv, snd_scale));
    }
}

static void
newreno_after_idle(struct cc_var *ccv)
{
    int rw;

    /*
    * If we've been idle for more than one retransmit timeout the old
    * congestion window is no longer current and we have to reduce it to
    * the restart window before we can transmit again.
    *
    * The restart window is the initial window or the last CWND, whichever
    * is smaller.
    *
    * This is done to prevent us from flooding the path with a full CWND at
    * wirespeed, overloading router and switch buffers along the way.
    *
    * See RFC5681 Section 4.1. "Restarting Idle Connections".
    */
    if (V_tcp_do_rfc3390)
        rw = min(4 * CCV(ccv, t_maxseg),
            max(2 * CCV(ccv, t_maxseg), 4380));
    else
        rw = CCV(ccv, t_maxseg) * 2;

    CCV(ccv, snd_cwnd) = min(rw, CCV(ccv, snd_cwnd));
}

/*
* Perform any necessary tasks before we enter congestion recovery.
*/
static void
newreno_cong_signal(struct cc_var *ccv, uint32_t type)
{
    struct newreno *nreno;
    uint32_t beta, beta_ecn, cwin, factor;
    u_int mss;

    cwin = CCV(ccv, snd_cwnd);
    mss = CCV(ccv, t_maxseg);
    nreno = ccv->cc_data;
    beta = (nreno == NULL) ? V_newreno_beta : nreno->beta;
    beta_ecn = (nreno == NULL) ? V_newreno_beta_ecn : nreno->beta_ecn;
    if (V_cc_do_abe && type == CC_ECN)
        factor = beta_ecn;
    else
        factor = beta;

    /* Catch algos which mistakenly leak private signal types. */
    KASSERT((type & CC_SIGPRIVMASK) == 0,
        ("%s: congestion signal type 0x%08x is private\n", __func__, type));

    cwin = max(((uint64_t)cwin * (uint64_t)factor) / (100ULL * (uint64_t)mss),
        2) * mss;

    switch (type) {
    case CC_NDUPACK:
        if (!IN_FASTRECOVERY(CCV(ccv, t_flags))) {
            if (IN_CONGRECOVERY(CCV(ccv, t_flags) &&
                V_cc_do_abe && V_cc_abe_frlossreduce)) {
                CCV(ccv, snd_ssthresh) =
                    ((uint64_t)CCV(ccv, snd_ssthresh) *
                    (uint64_t)beta) /
                    (100ULL * (uint64_t)beta_ecn);
            }
            if (!IN_CONGRECOVERY(CCV(ccv, t_flags)))
                CCV(ccv, snd_ssthresh) = cwin;
            ENTER_RECOVERY(CCV(ccv, t_flags));
        }
        break;
    case CC_ECN:
        if (!IN_CONGRECOVERY(CCV(ccv, t_flags))) {
            CCV(ccv, snd_ssthresh) = cwin;
            CCV(ccv, snd_cwnd) = cwin;
            ENTER_CONGRECOVERY(CCV(ccv, t_flags));
        }
        break;
    }
}

/*
* Perform any necessary tasks before we exit congestion recovery.
*/
static void
newreno_post_recovery(struct cc_var *ccv)
{
    int pipe;

    if (IN_FASTRECOVERY(CCV(ccv, t_flags))) {
        /*
        * Fast recovery will conclude after returning from this
        * function. Window inflation should have left us with
        * approximately snd_ssthresh outstanding data. But in case we
        * would be inclined to send a burst, better to do it via the
        * slow start mechanism.
        *
        * XXXLAS: Find a way to do this without needing curack
        */
        if (V_tcp_do_rfc6675_pipe)
            pipe = tcp_compute_pipe(ccv->ccvc.tcp);
        else
            pipe = CCV(ccv, snd_max) - ccv->curack;

        if (pipe < CCV(ccv, snd_ssthresh))
            /*
            * Ensure that cwnd does not collapse to 1 MSS under
            * adverse conditons. Implements RFC6582
            */
            CCV(ccv, snd_cwnd) = max(pipe, CCV(ccv, t_maxseg)) +
                CCV(ccv, t_maxseg);
        else
            CCV(ccv, snd_cwnd) = CCV(ccv, snd_ssthresh);
    }
}

static int
newreno_ctl_output(struct cc_var *ccv, struct sockopt *sopt, void *buf)
{
    struct newreno *nreno;
    struct cc_newreno_opts *opt;

    if (sopt->sopt_valsize != sizeof(struct cc_newreno_opts))
        return (EMSGSIZE);

    nreno = ccv->cc_data;
    opt = buf;

    switch (sopt->sopt_dir) {
    case SOPT_SET:
        /* We cannot set without cc_data memory. */
        if (nreno == NULL) {
            nreno = newreno_malloc(ccv);
            if (nreno == NULL)
                return (ENOMEM);
        }
        switch (opt->name) {
        case CC_NEWRENO_BETA:
            nreno->beta = opt->val;
            break;
        case CC_NEWRENO_BETA_ECN:
            if (!V_cc_do_abe)
                return (EACCES);
            nreno->beta_ecn = opt->val;
            break;
        default:
            return (ENOPROTOOPT);
        }
        break;
    case SOPT_GET:
        switch (opt->name) {
        case CC_NEWRENO_BETA:
            opt->val = (nreno == NULL) ?
                V_newreno_beta : nreno->beta;
            break;
        case CC_NEWRENO_BETA_ECN:
            opt->val = (nreno == NULL) ?
                V_newreno_beta_ecn : nreno->beta_ecn;
            break;
        default:
            return (ENOPROTOOPT);
        }
        break;
    default:
        return (EINVAL);
    }

    return (0);
}

static int
newreno_beta_handler(SYSCTL_HANDLER_ARGS)
{
    int error;
    uint32_t new;

    new = *(uint32_t *)arg1;
    error = sysctl_handle_int(oidp, &new, 0, req);
    if (error == 0 && req->newptr != NULL ) {
        if (arg1 == &VNET_NAME(newreno_beta_ecn) && !V_cc_do_abe)
            error = EACCES;
        else if (new == 0 || new > 100)
            error = EINVAL;
        else
            *(uint32_t *)arg1 = new;
    }

    return (error);
}

SYSCTL_DECL(_net_inet_tcp_cc_newreno);
SYSCTL_NODE(_net_inet_tcp_cc, OID_AUTO, newreno, CTLFLAG_RW, NULL,
    "New Reno related settings");

SYSCTL_PROC(_net_inet_tcp_cc_newreno, OID_AUTO, beta,
    CTLFLAG_VNET | CTLTYPE_UINT | CTLFLAG_RW,
    &VNET_NAME(newreno_beta), 3, &newreno_beta_handler, "IU",
    "New Reno beta, specified as number between 1 and 100");

SYSCTL_PROC(_net_inet_tcp_cc_newreno, OID_AUTO, beta_ecn,
    CTLFLAG_VNET | CTLTYPE_UINT | CTLFLAG_RW,
    &VNET_NAME(newreno_beta_ecn), 3, &newreno_beta_handler, "IU",
    "New Reno beta ecn, specified as number between 1 and 100");

DECLARE_CC_MODULE(newreno, &newreno_cc_algo);
\end{minted}
\captionof{listing}{The implementation file for NewReno in FreeBSD.}
\label{code:newreno.c}
\end{code}









\section{CUBIC}

\todo{...}









\section{Dynamic ABE}

\todo{brief description... also mention kernel src download and "make load/unload" etc...}

\todo{show code}

% \begin{code}
% \file{cc\_abe.c}
% \begin{minted}{c}

% \end{minted}
% \captionof{listing}{\todo{...}}
% \label{code:abe.c}
% \end{code}

\begin{code}
\file{Makefile}
\begin{minted}{bash}
KMOD=	abe
SRCS=	abe.c
.include <bsd.kmod.mk>
\end{minted}
\captionof{listing}{\todo{...}}
\label{code:makefile}
\end{code}